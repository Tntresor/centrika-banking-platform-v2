-- Migration: 001_create_users_table.sql
CREATE TABLE IF NOT EXISTS users (
    id BIGSERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    
    -- Encrypted phone and email with searchable hashes
    phone_encrypted TEXT NOT NULL,
    phone_hash VARCHAR(128) NOT NULL UNIQUE,
    email_encrypted TEXT,
    email_hash VARCHAR(128) UNIQUE,
    
    -- Password hash using bcrypt
    password_hash VARCHAR(255) NOT NULL,
    
    -- User status and preferences
    kyc_status VARCHAR(20) DEFAULT 'pending' CHECK (kyc_status IN ('pending', 'verified', 'rejected')),
    is_active BOOLEAN DEFAULT true,
    preferred_language VARCHAR(5) DEFAULT 'en' CHECK (preferred_language IN ('en', 'rw', 'fr')),
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_login TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_phone_hash_check CHECK (LENGTH(phone_hash) = 128),
    CONSTRAINT users_email_hash_check CHECK (email_hash IS NULL OR LENGTH(email_hash) = 128)
);

-- Indexes for performance
CREATE INDEX idx_users_phone_hash ON users(phone_hash);
CREATE INDEX idx_users_email_hash ON users(email_hash) WHERE email_hash IS NOT NULL;
CREATE INDEX idx_users_kyc_status ON users(kyc_status);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Migration: 002_create_wallets_table.sql
CREATE TABLE IF NOT EXISTS wallets (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Wallet details
    balance DECIMAL(15,2) DEFAULT 0.00 CHECK (balance >= 0),
    currency VARCHAR(3) DEFAULT 'RWF' CHECK (currency IN ('RWF', 'USD', 'EUR')),
    
    -- KYC and limits
    kyc_level INTEGER DEFAULT 1 CHECK (kyc_level BETWEEN 1 AND 3),
    daily_limit DECIMAL(15,2) DEFAULT 50000.00,
    monthly_limit DECIMAL(15,2) DEFAULT 1000000.00,
    
    -- Status
    is_active BOOLEAN DEFAULT true,
    is_frozen BOOLEAN DEFAULT false,
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Constraints
    UNIQUE(user_id, currency)
);

-- Indexes
CREATE INDEX idx_wallets_user_id ON wallets(user_id);
CREATE INDEX idx_wallets_currency ON wallets(currency);

-- Migration: 003_create_security_tables.sql

-- Failed login attempts tracking
CREATE TABLE IF NOT EXISTS failed_logins (
    id BIGSERIAL PRIMARY KEY,
    phone_hash VARCHAR(128) NOT NULL,
    attempts INTEGER DEFAULT 1,
    first_attempt TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_attempt TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    
    UNIQUE(phone_hash)
);

-- Account lockouts
CREATE TABLE IF NOT EXISTS account_lockouts (
    id BIGSERIAL PRIMARY KEY,
    phone_hash VARCHAR(128) NOT NULL UNIQUE,
    locked_until TIMESTAMP WITH TIME ZONE NOT NULL,
    reason VARCHAR(100) DEFAULT 'failed_login_attempts',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Audit logs for security and compliance
CREATE TABLE IF NOT EXISTS audit_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    action VARCHAR(50) NOT NULL,
    resource_type VARCHAR(50),
    resource_id VARCHAR(100),
    
    -- Event details
    event_data JSONB,
    correlation_id UUID,
    
    -- Request context
    ip_address INET,
    user_agent TEXT,
    session_id VARCHAR(255),
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Indexes for common queries
    CONSTRAINT audit_logs_action_check CHECK (action ~ '^[A-Z_]+$')
);

-- Indexes for audit logs
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX idx_audit_logs_correlation_id ON audit_logs(correlation_id) WHERE correlation_id IS NOT NULL;
CREATE INDEX idx_audit_logs_event_data ON audit_logs USING GIN(event_data);

-- Migration: 004_create_sessions_table.sql
CREATE TABLE IF NOT EXISTS user_sessions (
    id VARCHAR(128) PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Session data
    session_data JSONB,
    
    -- Security tracking
    ip_address INET,
    user_agent TEXT,
    device_fingerprint VARCHAR(255),
    
    -- Status
    is_active BOOLEAN DEFAULT true,
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_accessed TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    
    -- Constraints
    CONSTRAINT user_sessions_expires_check CHECK (expires_at > created_at)
);

-- Indexes
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_expires_at ON user_sessions(expires_at);
CREATE INDEX idx_user_sessions_active ON user_sessions(is_active, expires_at);

-- Migration: 005_create_functions_and_triggers.sql

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers for updated_at
CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_wallets_updated_at 
    BEFORE UPDATE ON wallets 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to clean expired sessions
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_sessions 
    WHERE expires_at < NOW() - INTERVAL '1 day';
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to clean old audit logs (keep last 2 years)
CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM audit_logs 
    WHERE created_at < NOW() - INTERVAL '2 years';
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Migration: 006_create_security_views.sql

-- View for user security status
CREATE OR REPLACE VIEW user_security_status AS
SELECT 
    u.id,
    u.phone_hash,
    u.is_active,
    u.last_login,
    COALESCE(fl.attempts, 0) as failed_login_attempts,
    fl.last_attempt as last_failed_attempt,
    al.locked_until,
    CASE 
        WHEN al.locked_until > NOW() THEN true 
        ELSE false 
    END as is_locked,
    COUNT(us.id) as active_sessions
FROM users u
LEFT JOIN failed_logins fl ON u.phone_hash = fl.phone_hash
LEFT JOIN account_lockouts al ON u.phone_hash = al.phone_hash
LEFT JOIN user_sessions us ON u.id = us.user_id AND us.is_active = true AND us.expires_at > NOW()
GROUP BY u.id, u.phone_hash, u.is_active, u.last_login, fl.attempts, fl.last_attempt, al.locked_until;

-- View for audit trail summary
CREATE OR REPLACE VIEW audit_summary AS
SELECT 
    user_id,
    action,
    COUNT(*) as event_count,
    MIN(created_at) as first_occurrence,
    MAX(created_at) as last_occurrence,
    COUNT(DISTINCT DATE(created_at)) as active_days
FROM audit_logs
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY user_id, action
ORDER BY user_id, event_count DESC;

-- Migration: 007_create_indexes_for_performance.sql

-- Partial indexes for active records only
CREATE INDEX idx_users_active_kyc ON users(kyc_status, created_at) WHERE is_active = true;
CREATE INDEX idx_wallets_active_balance ON wallets(balance, currency) WHERE is_active = true AND is_frozen = false;

-- Composite indexes for common query patterns
CREATE INDEX idx_audit_logs_user_action_date ON audit_logs(user_id, action, created_at);
CREATE INDEX idx_failed_logins_phone_attempts ON failed_logins(phone_hash, attempts, last_attempt);

-- Text search index for audit logs (if using full-text search)
CREATE INDEX idx_audit_logs_event_data_gin ON audit_logs USING GIN(to_tsvector('english', event_data::text));

-- Migration: 008_create_data_retention_policies.sql

-- Create partition tables for audit logs (by month)
CREATE TABLE audit_logs_template (LIKE audit_logs INCLUDING ALL);

-- Function to create monthly partitions
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name TEXT, start_date DATE)
RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    end_date DATE;
BEGIN
    partition_name := table_name || '_' || TO_CHAR(start_date, 'YYYY_MM');
    end_date := start_date + INTERVAL '1 month';
    
    EXECUTE FORMAT('CREATE TABLE IF NOT EXISTS %I PARTITION OF %I 
                   FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;

-- Migration: 009_create_security_constraints.sql

-- Row Level Security (RLS) for sensitive tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies (example - adjust based on your application roles)
CREATE POLICY users_own_data ON users 
    FOR ALL TO app_user 
    USING (id = current_setting('app.current_user_id')::BIGINT);

CREATE POLICY wallets_own_data ON wallets 
    FOR ALL TO app_user 
    USING (user_id = current_setting('app.current_user_id')::BIGINT);

-- Audit logs are read-only for app users
CREATE POLICY audit_logs_readonly ON audit_logs 
    FOR SELECT TO app_user 
    USING (user_id = current_setting('app.current_user_id')::BIGINT);

-- Migration: 010_insert_initial_data.sql

-- Insert audit action types for reference
INSERT INTO audit_action_types (action, description) VALUES
('USER_CREATED', 'New user account created'),
('USER_LOGIN', 'User successful login'),
('USER_LOGOUT', 'User logout'),
('PASSWORD_CHANGED', 'User password changed'),
('PROFILE_UPDATED', 'User profile information updated'),
('WALLET_CREATED', 'New wallet created'),
('TRANSACTION_INITIATED', 'Transaction started'),
('TRANSACTION_COMPLETED', 'Transaction completed'),
('TRANSACTION_FAILED', 'Transaction failed'),
('KYC_SUBMITTED', 'KYC documents submitted'),
('KYC_APPROVED', 'KYC verification approved'),
('KYC_REJECTED', 'KYC verification rejected'),
('SECURITY_VIOLATION', 'Security policy violation detected'),
('ACCOUNT_LOCKED', 'Account locked due to security'),
('ACCOUNT_UNLOCKED', 'Account unlocked by admin'),
('SESSION_CREATED', 'New user session created'),
('SESSION_EXPIRED', 'User session expired')
ON CONFLICT (action) DO NOTHING;