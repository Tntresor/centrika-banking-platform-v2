const express = require(â€˜expressâ€™);
const cors = require(â€˜corsâ€™);
const { Client } = require(â€˜pgâ€™);

const app = express();
const PORT = process.env.PORT || 8000;
const HOST = process.env.HOST || â€˜0.0.0.0â€™;

// Environment variables
process.env.NODE_ENV = â€˜productionâ€™;
process.env.DATABASE_URL = â€˜postgresql://postgres.tzwzmzakxgatyvhvngez:Xentrika2025!@aws-0-eu-west-3.pooler.supabase.com:6543/postgresâ€™;
process.env.JWT_SECRET = â€˜eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR6d3ptemFreGdhdHl2aHZuZ2V6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAzODUwOTAsImV4cCI6MjA2NTk2MTA5MH0.623RCZAPWUGJlQgsfYRXS3E6riACjb2MLJACOZ2gHPcâ€™;

// Database client
let dbClient = null;

async function connectDB() {
try {
console.log(â€˜ðŸ”Œ Attempting database connectionâ€¦â€™);
dbClient = new Client({
connectionString: process.env.DATABASE_URL,
ssl: { rejectUnauthorized: false },
connectionTimeoutMillis: 5000, // 5 second timeout
});

```
// Add connection timeout
const connectionPromise = dbClient.connect();
const timeoutPromise = new Promise((_, reject) => 
  setTimeout(() => reject(new Error('Connection timeout after 8 seconds')), 8000)
);

await Promise.race([connectionPromise, timeoutPromise]);
console.log('âœ… Connected to Supabase database');
return true;
```

} catch (error) {
console.error(â€˜âŒ Database connection failed:â€™, error.message);
if (dbClient) {
try {
await dbClient.end();
} catch (e) {
// Ignore cleanup errors
}
dbClient = null;
}
return false;
}
}

// Middleware
app.use(cors({ origin: â€˜*â€™ }));
app.use(express.json());

// Health check
app.get(â€™/â€™, (req, res) => {
res.json({
service: â€˜Centrika Neobank APIâ€™,
status: â€˜runningâ€™,
version: â€˜1.0.0â€™,
timestamp: new Date().toISOString(),
database: dbClient ? â€˜connectedâ€™ : â€˜disconnectedâ€™
});
});

app.get(â€™/healthâ€™, (req, res) => {
res.json({
status: â€˜healthyâ€™,
timestamp: new Date().toISOString(),
database: dbClient ? â€˜connectedâ€™ : â€˜disconnectedâ€™
});
});

// Admin login endpoint
app.post(â€™/api/admin/loginâ€™, async (req, res) => {
try {
const { email, password } = req.body;

```
if (!email || !password) {
  return res.status(400).json({
    success: false,
    message: 'Email and password are required'
  });
}

if (!dbClient) {
  return res.status(500).json({
    success: false,
    message: 'Database connection unavailable'
  });
}

const result = await dbClient.query(
  'SELECT * FROM admin_users WHERE email = $1 AND is_active = true',
  [email]
);

if (result.rows.length === 0 || password !== 'password') {
  return res.status(401).json({
    success: false,
    message: 'Invalid credentials'
  });
}

const admin = result.rows[0];
const jwt = require('jsonwebtoken');
const token = jwt.sign(
  { 
    id: admin.id, 
    email: admin.email, 
    role: admin.role 
  },
  process.env.JWT_SECRET,
  { expiresIn: '24h' }
);

res.json({
  success: true,
  data: {
    token,
    user: {
      id: admin.id,
      email: admin.email,
      role: admin.role
    }
  }
});
```

} catch (error) {
console.error(â€˜Admin login error:â€™, error);
res.status(500).json({
success: false,
message: â€˜Login failedâ€™
});
}
});

// Dashboard metrics endpoint
app.get(â€™/api/admin/metricsâ€™, async (req, res) => {
try {
if (!dbClient) {
return res.status(500).json({
success: false,
message: â€˜Database connection unavailableâ€™
});
}

```
const [usersResult, walletsResult, transactionsResult] = await Promise.all([
  dbClient.query('SELECT COUNT(*) as total, COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as daily FROM users'),
  dbClient.query('SELECT SUM(CAST(balance as DECIMAL)) as total_balance, COUNT(*) as active_wallets FROM wallets WHERE is_active = true'),
  dbClient.query('SELECT COUNT(*) as total_transactions, COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as daily_transactions FROM transactions')
]);

const kycApprovedResult = await dbClient.query(
  "SELECT COUNT(*) FILTER (WHERE kyc_status = 'approved') * 100.0 / NULLIF(COUNT(*), 0) as kyc_rate FROM users WHERE kyc_status IS NOT NULL"
);

const metrics = {
  dailySignups: parseInt(usersResult.rows[0].daily) || 0,
  successfulKYCRate: parseFloat(kycApprovedResult.rows[0].kyc_rate) || 0,
  transactionCount: parseInt(transactionsResult.rows[0].daily_transactions) || 0,
  totalLedgerBalance: parseFloat(walletsResult.rows[0].total_balance) || 0,
  activeUsers: parseInt(walletsResult.rows[0].active_wallets) || 0,
};

res.json({
  success: true,
  data: metrics,
});
```

} catch (error) {
console.error(â€˜Error fetching metrics:â€™, error);
res.status(500).json({
success: false,
message: â€˜Failed to fetch dashboard metricsâ€™
});
}
});

// User registration
app.post(â€™/api/auth/registerâ€™, async (req, res) => {
try {
const { firstName, lastName, phone, password } = req.body;

```
if (!firstName || !lastName || !phone || !password) {
  return res.status(400).json({
    success: false,
    message: 'All fields are required'
  });
}

if (!dbClient) {
  return res.status(500).json({
    success: false,
    message: 'Database connection unavailable'
  });
}

const bcrypt = require('bcryptjs');
const hashedPassword = await bcrypt.hash(password, 10);

const result = await dbClient.query(
  'INSERT INTO users (first_name, last_name, phone, email, password_hash, kyc_status, is_active, preferred_language) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *',
  [firstName, lastName, phone, `${phone}@centrika.rw`, hashedPassword, 'pending', true, 'en']
);

const user = result.rows[0];

// Create wallet for user
await dbClient.query(
  'INSERT INTO wallets (user_id, balance, currency, is_active, kyc_level) VALUES ($1, $2, $3, $4, $5)',
  [user.id, '1000.00', 'RWF', true, 1]
);

res.json({
  success: true,
  message: 'Account created successfully',
  data: { userId: user.id }
});
```

} catch (error) {
console.error(â€˜Registration error:â€™, error);
if (error.code === â€˜23505â€™) {
res.status(400).json({
success: false,
message: â€˜Phone number already registeredâ€™
});
} else {
res.status(500).json({
success: false,
message: â€˜Registration failedâ€™
});
}
}
});

// User login
app.post(â€™/api/auth/loginâ€™, async (req, res) => {
try {
const { phone, password } = req.body;

```
if (!phone || !password) {
  return res.status(400).json({
    success: false,
    message: 'Phone and password are required'
  });
}

if (!dbClient) {
  return res.status(500).json({
    success: false,
    message: 'Database connection unavailable'
  });
}

const result = await dbClient.query(
  'SELECT * FROM users WHERE phone = $1 AND is_active = true',
  [phone]
);

if (result.rows.length === 0) {
  return res.status(401).json({
    success: false,
    message: 'Invalid credentials'
  });
}

const user = result.rows[0];
const bcrypt = require('bcryptjs');
const isValidPassword = await bcrypt.compare(password, user.password_hash);

if (!isValidPassword) {
  return res.status(401).json({
    success: false,
    message: 'Invalid credentials'
  });
}

const jwt = require('jsonwebtoken');
const token = jwt.sign(
  { userId: user.id, phone: user.phone },
  process.env.JWT_SECRET,
  { expiresIn: '24h' }
);

res.json({
  success: true,
  data: {
    token,
    user: {
      id: user.id,
      firstName: user.first_name,
      lastName: user.last_name,
      phone: user.phone
    }
  }
});
```

} catch (error) {
console.error(â€˜Login error:â€™, error);
res.status(500).json({
success: false,
message: â€˜Login failedâ€™
});
}
});

// Start server immediately - donâ€™t wait for database
async function startServer() {
console.log(â€˜ðŸš€ Starting Centrika Banking Serverâ€™);
console.log(`Node version: ${process.version}`);
console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
console.log(`Host: ${HOST}`);
console.log(`Port: ${PORT}`);

// Start HTTP server first
const server = app.listen(PORT, HOST, () => {
console.log(`âœ… Server running on http://${HOST}:${PORT}`);
console.log(`Health check: http://${HOST}:${PORT}/health`);
console.log(`Available endpoints:`);
console.log(`  - GET  ${HOST}:${PORT}/`);
console.log(`  - GET  ${HOST}:${PORT}/health`);
console.log(`  - POST ${HOST}:${PORT}/api/auth/register`);
console.log(`  - POST ${HOST}:${PORT}/api/auth/login`);
console.log(`  - POST ${HOST}:${PORT}/api/admin/login`);
console.log(`  - GET  ${HOST}:${PORT}/api/admin/metrics`);
});

// Connect to database in background - donâ€™t block server startup
console.log(â€˜ðŸ“¡ Attempting database connection in backgroundâ€¦â€™);
connectDB().then(dbConnected => {
console.log(`Database: ${dbConnected ? 'âœ… Connected' : 'âŒ Disconnected'}`);
if (!dbConnected) {
console.log(â€˜âš ï¸  Server running without database - some endpoints will failâ€™);
console.log(â€˜ðŸ“ Note: Visit /health to check statusâ€™);
}
}).catch(error => {
console.error(â€˜ðŸ’¥ Database connection error:â€™, error.message);
console.log(â€˜âš ï¸  Server running without database - some endpoints will failâ€™);
});

// Graceful shutdown
process.on(â€˜SIGINTâ€™, async () => {
console.log(â€™\nðŸ›‘ Shutting down serverâ€¦â€™);
if (dbClient) {
try {
await dbClient.end();
console.log(â€˜ðŸ“¡ Database connection closedâ€™);
} catch (error) {
console.error(â€˜Error closing database:â€™, error.message);
}
}
server.close(() => {
console.log(â€˜ðŸ”Œ Server closedâ€™);
process.exit(0);
});
});

return server;
}

// Start the server
startServer().catch(error => {
console.error(â€˜ðŸ’¥ Failed to start server:â€™, error);
process.exit(1);
});