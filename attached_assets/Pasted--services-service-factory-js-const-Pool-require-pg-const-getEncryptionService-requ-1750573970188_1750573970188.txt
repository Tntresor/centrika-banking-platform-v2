// services/service-factory.js
const { Pool } = require('pg');
const { getEncryptionService } = require('./encryption-service');
const { UserService } = require('./user-service');
const { StorageService } = require('../utils/storage');
const { AuditService } = require('./audit-service');
const { CONFIG, validateConfig } = require('../config');
const { Logger } = require('../utils/logger');

class ServiceFactory {
  constructor() {
    this.logger = new Logger('ServiceFactory');
    this.services = new Map();
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) {
      return;
    }

    try {
      // Validate configuration
      validateConfig();

      // Initialize database pool
      this.dbPool = new Pool({
        connectionString: CONFIG.database.url,
        ssl: CONFIG.database.ssl ? { rejectUnauthorized: false } : false,
        min: CONFIG.database.pool.min,
        max: CONFIG.database.pool.max,
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 5000
      });

      // Test database connection
      await this.dbPool.query('SELECT NOW()');
      this.logger.info('Database connection established');

      // Initialize services in dependency order
      await this._initializeServices();

      this.initialized = true;
      this.logger.info('ServiceFactory initialized successfully');

    } catch (error) {
      this.logger.error('ServiceFactory initialization failed', { error: error.message });
      throw error;
    }
  }

  async _initializeServices() {
    // 1. Initialize encryption service
    const encryptionService = getEncryptionService({
      encryptionKey: CONFIG.encryption.key
    });
    this.services.set('encryption', encryptionService);

    // 2. Initialize storage service
    const storageService = new StorageService(this.dbPool, encryptionService);
    this.services.set('storage', storageService);

    // 3. Initialize audit service
    const auditService = new AuditService(storageService);
    this.services.set('audit', auditService);

    // 4. Initialize user service
    const userService = new UserService(
      storageService,
      encryptionService,
      auditService
    );
    this.services.set('user', userService);

    this.logger.info('All services initialized');
  }

  getService(name) {
    if (!this.initialized) {
      throw new Error('ServiceFactory not initialized. Call initialize() first.');
    }

    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service '${name}' not found`);
    }

    return service;
  }

  async shutdown() {
    try {
      this.logger.info('Shutting down services...');

      // Close database pool
      if (this.dbPool) {
        await this.dbPool.end();
        this.logger.info('Database pool closed');
      }

      // Clear services
      this.services.clear();
      this.initialized = false;

      this.logger.info('ServiceFactory shutdown complete');
    } catch (error) {
      this.logger.error('Error during shutdown', { error: error.message });
    }
  }

  // Health check for all services
  async healthCheck() {
    const results = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {}
    };

    try {
      // Database health
      const dbStart = Date.now();
      await this.dbPool.query('SELECT 1');
      results.services.database = {
        status: 'healthy',
        responseTime: Date.now() - dbStart
      };

      // Encryption service health
      const encryptionService = this.getService('encryption');
      const testData = 'health-check';
      const encrypted = encryptionService.encrypt(testData);
      const decrypted = encryptionService.decrypt(encrypted);
      
      results.services.encryption = {
        status: decrypted === testData ? 'healthy' : 'unhealthy',
        responseTime: 1 // Very fast operation
      };

    } catch (error) {
      results.status = 'unhealthy';
      results.error = error.message;
    }

    return results;
  }
}

// Singleton instance
let serviceFactory = null;

function getServiceFactory() {
  if (!serviceFactory) {
    serviceFactory = new ServiceFactory();
  }
  return serviceFactory;
}

// Enhanced Audit Service
class AuditService {
  constructor(storageService) {
    this.storage = storageService;
    this.logger = new Logger('AuditService');
  }

  async log(action, userId, eventData = {}, client = null) {
    try {
      const auditEntry = {
        user_id: userId,
        action,
        event_data: eventData,
        correlation_id: eventData.correlationId || null,
        ip_address: eventData.clientInfo?.ip || null,
        user_agent: eventData.clientInfo?.userAgent || null,
        session_id: eventData.sessionId || null,
        created_at: new Date()
      };

      const query = `
        INSERT INTO audit_logs (
          user_id, action, event_data, correlation_id, 
          ip_address, user_agent, session_id, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id
      `;

      const values = [
        auditEntry.user_id,
        auditEntry.action,
        JSON.stringify(auditEntry.event_data),
        auditEntry.correlation_id,
        auditEntry.ip_address,
        auditEntry.user_agent,
        auditEntry.session_id,
        auditEntry.created_at
      ];

      const executor = client || this.storage.pool;
      const result = await executor.query(query, values);

      this.logger.debug('Audit log created', {
        auditId: result.rows[0].id,
        action,
        userId,
        correlationId: auditEntry.correlation_id
      });

      return result.rows[0].id;

    } catch (error) {
      this.logger.error('Failed to create audit log', {
        action,
        userId,
        error: error.message
      });
      // Don't throw - audit logging shouldn't break main operations
    }
  }

  async getAuditTrail(userId, options = {}) {
    try {
      const {
        limit = 50,
        offset = 0,
        action = null,
        startDate = null,
        endDate = null
      } = options;

      let query = `
        SELECT 
          id, action, event_data, ip_address, 
          user_agent, created_at, correlation_id
        FROM audit_logs 
        WHERE user_id = $1
      `;

      const params = [userId];
      let paramIndex = 2;

      if (action) {
        query += ` AND action = $${paramIndex}`;
        params.push(action);
        paramIndex++;
      }

      if (startDate) {
        query += ` AND created_at >= $${paramIndex}`;
        params.push(startDate);
        paramIndex++;
      }

      if (endDate) {
        query += ` AND created_at <= $${paramIndex}`;
        params.push(endDate);
        paramIndex++;
      }

      query += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
      params.push(limit, offset);

      const result = await this.storage.pool.query(query, params);
      return result.rows;

    } catch (error) {
      this.logger.error('Failed to get audit trail', {
        userId,
        error: error.message
      });
      throw error;
    }
  }
}

// Audit action constants
const auditActions = {
  USER_CREATED: 'USER_CREATED',
  USER_LOGIN: 'USER_LOGIN',
  USER