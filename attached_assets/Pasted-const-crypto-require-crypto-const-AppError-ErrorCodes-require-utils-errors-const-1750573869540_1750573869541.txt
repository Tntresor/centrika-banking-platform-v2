const crypto = require('crypto');
const { AppError, ErrorCodes } = require('../utils/errors');
const { Logger } = require('../utils/logger');
const { CONFIG } = require('../config');

// Constants
const ALGORITHMS = {
  SYMMETRIC: 'aes-256-gcm',
  HASH: 'sha512'
};

const KEY_SIZES = {
  AES_256: 32,
  IV: 16,
  SALT: 32,
  AUTH_TAG: 16
};

const PBKDF2_CONFIG = {
  ITERATIONS: CONFIG.security.pbkdf2.iterations || 100000,
  KEY_LENGTH: 64
};

class EncryptionService {
  constructor(options = {}) {
    this.logger = new Logger('EncryptionService');
    
    // Initialize encryption key
    this.encryptionKey = this._initializeEncryptionKey(options.encryptionKey);
    
    // Validate key
    if (!this.encryptionKey || this.encryptionKey.length !== KEY_SIZES.AES_256) {
      throw new AppError(ErrorCodes.CRYPTO_ERROR, 'Invalid encryption key size');
    }
    
    this.logger.info('EncryptionService initialized successfully');
  }

  /**
   * Encrypt data using AES-256-GCM
   * @param {string} plaintext - Data to encrypt
   * @param {string} [additionalData] - Additional authenticated data
   * @returns {Object} Encrypted data with IV and auth tag
   */
  encrypt(plaintext, additionalData = null) {
    if (!plaintext) {
      return null;
    }

    if (typeof plaintext !== 'string') {
      throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Plaintext must be a string');
    }

    try {
      // Generate random IV
      const iv = crypto.randomBytes(KEY_SIZES.IV);
      
      // Create cipher
      const cipher = crypto.createCipheriv(ALGORITHMS.SYMMETRIC, this.encryptionKey, iv);
      
      // Add additional authenticated data if provided
      if (additionalData) {
        cipher.setAAD(Buffer.from(additionalData, 'utf8'));
      }
      
      // Encrypt
      let encrypted = cipher.update(plaintext, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      // Get authentication tag
      const authTag = cipher.getAuthTag();
      
      const result = {
        iv: iv.toString('hex'),
        encryptedData: encrypted,
        authTag: authTag.toString('hex'),
        algorithm: ALGORITHMS.SYMMETRIC
      };

      // Add AAD indicator if used
      if (additionalData) {
        result.hasAAD = true;
      }

      return result;

    } catch (error) {
      this.logger.error('Encryption failed', { error: error.message });
      throw new AppError(ErrorCodes.CRYPTO_ERROR, 'Encryption failed', error);
    }
  }

  /**
   * Decrypt data encrypted with AES-256-GCM
   * @param {Object} encryptedData - Object containing encrypted data, IV, and auth tag
   * @param {string} [additionalData] - Additional authenticated data used during encryption
   * @returns {string|null} Decrypted plaintext or null if failed
   */
  decrypt(encryptedData, additionalData = null) {
    if (!encryptedData || !this._validateEncryptedData(encryptedData)) {
      return null;
    }

    try {
      const { iv, encryptedData: ciphertext, authTag, algorithm = ALGORITHMS.SYMMETRIC } = encryptedData;
      
      // Validate algorithm
      if (algorithm !== ALGORITHMS.SYMMETRIC) {
        throw new Error('Unsupported encryption algorithm');
      }

      // Create decipher
      const decipher = crypto.createDecipheriv(
        algorithm,
        this.encryptionKey,
        Buffer.from(iv, 'hex')
      );
      
      // Set authentication tag
      decipher.setAuthTag(Buffer.from(authTag, 'hex'));
      
      // Add additional authenticated data if provided
      if (additionalData) {
        decipher.setAAD(Buffer.from(additionalData, 'utf8'));
      }
      
      // Decrypt
      let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      
      return decrypted;

    } catch (error) {
      this.logger.warn('Decryption failed', { 
        error: error.message,
        hasAAD: !!additionalData 
      });
      return null;
    }
  }

  /**
   * Hash data using PBKDF2 with SHA-512
   * @param {string} data - Data to hash
   * @param {string} [salt] - Salt (generated if not provided)
   * @returns {Object} Hash and salt
   */
  hash(data, salt = null) {
    if (!data || typeof data !== 'string') {
      throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Data must be a non-empty string');
    }

    try {
      const saltBuffer = salt 
        ? Buffer.from(salt, 'hex')
        : crypto.randomBytes(KEY_SIZES.SALT);
      
      const hash = crypto.pbkdf2Sync(
        data,
        saltBuffer,
        PBKDF2_CONFIG.ITERATIONS,
        PBKDF2_CONFIG.KEY_LENGTH,
        ALGORITHMS.HASH
      );

      return {
        hash: hash.toString('hex'),
        salt: saltBuffer.toString('hex'),
        iterations: PBKDF2_CONFIG.ITERATIONS,
        algorithm: ALGORITHMS.HASH
      };

    } catch (error) {
      this.logger.error('Hashing failed', { error: error.message });
      throw new AppError(ErrorCodes.CRYPTO_ERROR, 'Hashing failed', error);
    }
  }

  /**
   * Verify data against hash
   * @param {string} data - Data to verify
   * @param {string} hash - Hash to verify against
   * @param {string} salt - Salt used in hashing
   * @param {number} [iterations] - Number of iterations (defaults to current config)
   * @returns {boolean} True if data matches hash
   */
  verifyHash(data, hash, salt, iterations = PBKDF2_CONFIG.ITERATIONS) {
    if (!data || !hash || !salt) {
      return false;
    }

    try {
      const computedHash = crypto.pbkdf2Sync(
        data,
        Buffer.from(salt, 'hex'),
        iterations,
        PBKDF2_CONFIG.KEY_LENGTH,
        ALGORITHMS.HASH
      );

      const expectedHash = Buffer.from(hash, 'hex');
      
      // Use constant-time comparison to prevent timing attacks
      return crypto.timingSafeEqual(computedHash, expectedHash);

    } catch (error) {
      this.logger.warn('Hash verification failed', { error: error.message });
      return false;
    }
  }

  /**
   * Generate cryptographically secure random bytes
   * @param {number} size - Number of bytes to generate
   * @param {string} [encoding] - Output encoding (default: 'hex')
   * @returns {string} Random bytes in specified encoding
   */
  generateRandomBytes(size, encoding = 'hex') {
    if (!Number.isInteger(size) || size <= 0) {
      throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Size must be a positive integer');
    }

    try {
      return crypto.randomBytes(size).toString(encoding);
    } catch (error) {
      this.logger.error('Random bytes generation failed', { error: error.message });
      throw new AppError(ErrorCodes.CRYPTO_ERROR, 'Random bytes generation failed', error);
    }
  }

  /**
   * Generate a secure random token
   * @param {number} [length] - Token length in bytes (default: 32)
   * @returns {string} Secure random token
   */
  generateToken(length = 32) {
    return this.generateRandomBytes(length, 'hex');
  }

  /**
   * Generate a cryptographic hash of data (one-way, fast)
   * @param {string} data - Data to hash
   * @param {string} [algorithm] - Hash algorithm (default: 'sha256')
   * @returns {string} Hash in hex format
   */
  quickHash(data, algorithm = 'sha256') {
    if (!data) {
      throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Data is required');
    }

    try {
      return crypto.createHash(algorithm).update(data, 'utf8').digest('hex');
    } catch (error) {
      this.logger.error('Quick hash failed', { error: error.message });
      throw new AppError(ErrorCodes.CRYPTO_ERROR, 'Hash generation failed', error);
    }
  }

  /**
   * Compare two strings in constant time to prevent timing attacks
   * @param {string} a - First string
   * @param {string} b - Second string
   * @returns {boolean} True if strings are equal
   */
  constantTimeCompare(a, b) {
    if (typeof a !== 'string' || typeof b !== 'string') {
      return false;
    }

    if (a.length !== b.length) {
      return false;
    }

    try {
      const bufferA = Buffer.from(a, 'utf8');
      const bufferB = Buffer.from(b, 'utf8');
      return crypto.timingSafeEqual(bufferA, bufferB);
    } catch (error) {
      return false;
    }
  }

  /**
   * Rotate encryption key (for key rotation scenarios)
   * @param {string} newKey - New encryption key in hex format
   */
  rotateKey(newKey) {
    const newKeyBuffer = Buffer.from(newKey, 'hex');
    
    if (newKeyBuffer.length !== KEY_SIZES.AES_256) {
      throw new AppError(ErrorCodes.CRYPTO_ERROR, 'Invalid new key size');
    }

    const oldKey = this.encryptionKey;
    this.encryptionKey = newKeyBuffer;
    
    this.logger.info('Encryption key rotated successfully');
    
    return {
      oldKeyHash: crypto.createHash('sha256').update(oldKey).digest('hex').substring(0, 8),
      newKeyHash: crypto.createHash('sha256').update(newKeyBuffer).digest('hex').substring(0, 8)
    };
  }

  // Private methods
  _initializeEncryptionKey(providedKey) {
    if (providedKey) {
      if (typeof providedKey === 'string') {
        return Buffer.from(providedKey, 'hex');
      }
      if (Buffer.isBuffer(providedKey)) {
        return providedKey;
      }
    }

    // Check for environment variable
    const envKey = process.env.ENCRYPTION_KEY;
    if (envKey) {
      return Buffer.from(envKey, 'hex');
    }

    // In production, throw error if no key provided
    if (process.env.NODE_ENV === 'production') {
      throw new AppError(ErrorCodes.CONFIG_ERROR, 'Encryption key must be provided in production');
    }

    // Generate random key for development (with warning)
    this.logger.warn('Using random encryption key - data will not persist across restarts');
    return crypto.randomBytes(KEY_SIZES.AES_256);
  }

  _validateEncryptedData(data) {
    return data && 
           typeof data === 'object' &&
           typeof data.iv === 'string' &&
           typeof data.encryptedData === 'string' &&
           typeof data.authTag === 'string' &&
           data.iv.length === KEY_SIZES.IV * 2 && // hex encoded
           data.authTag.length === KEY_SIZES.AUTH_TAG * 2; // hex encoded
  }
}

// Singleton instance
let encryptionService = null;

/**
 * Get singleton instance of EncryptionService
 * @param {Object} [options] - Configuration options
 * @returns {EncryptionService} Singleton instance
 */
function getEncryptionService(options = {}) {
  if (!encryptionService) {
    encryptionService = new EncryptionService(options);
  }
  return encryptionService;
}

module.exports = { 
  EncryptionService, 
  getEncryptionService,
  ALGORITHMS,
  KEY_SIZES 
};