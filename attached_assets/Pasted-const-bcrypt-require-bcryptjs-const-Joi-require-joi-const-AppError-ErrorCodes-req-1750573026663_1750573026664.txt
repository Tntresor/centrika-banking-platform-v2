const bcrypt = require('bcryptjs');
const Joi = require('joi');
const { AppError, ErrorCodes } = require('../utils/errors');
const { Logger } = require('../utils/logger');
const { RateLimiter } = require('../utils/rate-limiter');
const { auditLog, auditActions } = require('./audit-service');
const { validatePassword, sanitizePhone, validateEmail } = require('../utils/security');
const { CONFIG } = require('../config');

// Validation schemas
const createUserSchema = Joi.object({
  firstName: Joi.string().trim().min(2).max(50).required(),
  lastName: Joi.string().trim().min(2).max(50).required(),
  phone: Joi.string().pattern(/^\+?[1-9]\d{1,14}$/).required(),
  email: Joi.string().email().optional(),
  password: Joi.string().min(8).required(),
  preferredLanguage: Joi.string().valid('en', 'rw', 'fr').default('en')
});

const authSchema = Joi.object({
  phone: Joi.string().pattern(/^\+?[1-9]\d{1,14}$/).required(),
  password: Joi.string().required()
});

const changePasswordSchema = Joi.object({
  currentPassword: Joi.string().required(),
  newPassword: Joi.string().min(8).required()
});

class UserService {
  constructor(storage, encryptionService, auditService) {
    this.storage = storage;
    this.encryption = encryptionService;
    this.audit = auditService;
    this.logger = new Logger('UserService');
    this.rateLimiter = new RateLimiter();
    
    // Configuration
    this.config = {
      saltRounds: CONFIG.security.bcrypt.rounds,
      defaultWalletBalance: CONFIG.wallet.defaultBalance,
      maxLoginAttempts: CONFIG.security.maxLoginAttempts,
      lockoutDuration: CONFIG.security.lockoutDuration
    };
  }

  /**
   * Create a new user with validation and security checks
   * @param {Object} userData - User registration data
   * @param {Object} clientInfo - Client metadata (IP, user agent, etc.)
   * @returns {Promise<Object>} Created user and wallet information
   */
  async createUser(userData, clientInfo = {}) {
    const startTime = Date.now();
    const correlationId = this._generateCorrelationId();
    
    try {
      // Rate limiting
      await this._checkRateLimit('user_creation', clientInfo.ip);
      
      // Input validation
      const validatedData = await this._validateUserData(userData);
      
      // Check for existing user
      await this._checkUserExists(validatedData.phone, validatedData.email);
      
      // Execute in transaction
      const result = await this.storage.executeTransaction(async (client) => {
        return await this._createUserTransaction(validatedData, clientInfo, client, correlationId);
      });

      this.logger.info('User created successfully', {
        correlationId,
        userId: result.user.id,
        duration: Date.now() - startTime
      });

      return result;

    } catch (error) {
      this.logger.error('User creation failed', {
        correlationId,
        error: error.message,
        userData: this._sanitizeUserDataForLog(userData),
        duration: Date.now() - startTime
      });
      throw error;
    }
  }

  /**
   * Authenticate user with enhanced security
   * @param {string} phone - User phone number
   * @param {string} password - User password
   * @param {Object} clientInfo - Client metadata
   * @returns {Promise<Object|null>} User data if authenticated, null otherwise
   */
  async authenticateUser(phone, password, clientInfo = {}) {
    const startTime = Date.now();
    const correlationId = this._generateCorrelationId();
    
    try {
      // Rate limiting for login attempts
      await this._checkRateLimit('login_attempt', clientInfo.ip);
      
      // Input validation
      const { error, value } = authSchema.validate({ phone, password });
      if (error) {
        throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Invalid input', error.details);
      }

      const sanitizedPhone = sanitizePhone(value.phone);
      
      // Check if account is locked
      await this._checkAccountLockout(sanitizedPhone);
      
      // Get user
      const user = await this.storage.getUserByPhone(sanitizedPhone);
      
      if (!user) {
        await this._handleFailedLogin(null, 'invalid_phone', sanitizedPhone, clientInfo, correlationId);
        return null;
      }

      // Verify password
      const isValidPassword = await this._verifyPassword(password, user.password_hash);
      
      if (!isValidPassword) {
        await this._handleFailedLogin(user.id, 'invalid_password', sanitizedPhone, clientInfo, correlationId);
        return null;
      }

      // Success - reset failed attempts and log
      await this._handleSuccessfulLogin(user, clientInfo, correlationId);
      
      this.logger.info('User authenticated successfully', {
        correlationId,
        userId: user.id,
        duration: Date.now() - startTime
      });

      return this._formatUserResponse(user);

    } catch (error) {
      this.logger.error('Authentication failed', {
        correlationId,
        phone: sanitizePhone(phone),
        error: error.message,
        duration: Date.now() - startTime
      });
      throw error;
    }
  }

  /**
   * Change user password with security validation
   * @param {number} userId - User ID
   * @param {string} currentPassword - Current password
   * @param {string} newPassword - New password
   * @param {Object} clientInfo - Client metadata
   * @returns {Promise<Object>} Success confirmation
   */
  async changePassword(userId, currentPassword, newPassword, clientInfo = {}) {
    const startTime = Date.now();
    const correlationId = this._generateCorrelationId();
    
    try {
      // Rate limiting
      await this._checkRateLimit('password_change', clientInfo.ip);
      
      // Input validation
      const { error, value } = changePasswordSchema.validate({ currentPassword, newPassword });
      if (error) {
        throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Invalid input', error.details);
      }

      // Additional password strength validation
      if (!validatePassword(value.newPassword)) {
        throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Password does not meet security requirements');
      }

      const result = await this.storage.executeTransaction(async (client) => {
        return await this._changePasswordTransaction(userId, value.currentPassword, value.newPassword, clientInfo, client, correlationId);
      });

      this.logger.info('Password changed successfully', {
        correlationId,
        userId,
        duration: Date.now() - startTime
      });

      return result;

    } catch (error) {
      this.logger.error('Password change failed', {
        correlationId,
        userId,
        error: error.message,
        duration: Date.now() - startTime
      });
      throw error;
    }
  }

  // Private helper methods
  async _validateUserData(userData) {
    const { error, value } = createUserSchema.validate(userData);
    if (error) {
      throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Invalid user data', error.details);
    }

    // Additional password validation
    if (!validatePassword(value.password)) {
      throw new AppError(ErrorCodes.VALIDATION_ERROR, 'Password does not meet security requirements');
    }

    // Sanitize phone
    value.phone = sanitizePhone(value.phone);
    
    // Generate email if not provided
    if (!value.email) {
      value.email = `${value.phone.replace(/\+/g, '')}@centrika.rw`;
    }

    return value;
  }

  async _checkUserExists(phone, email) {
    const [existingPhone, existingEmail] = await Promise.all([
      this.storage.getUserByPhone(phone),
      email ? this.storage.getUserByEmail(email) : null
    ]);

    if (existingPhone) {
      throw new AppError(ErrorCodes.USER_EXISTS, 'User with this phone number already exists');
    }

    if (existingEmail) {
      throw new AppError(ErrorCodes.USER_EXISTS, 'User with this email already exists');
    }
  }

  async _createUserTransaction(userData, clientInfo, client, correlationId) {
    // Hash password
    const hashedPassword = await bcrypt.hash(userData.password, this.config.saltRounds);

    // Encrypt sensitive data
    const encryptedPhone = this.encryption.encrypt(userData.phone);
    const encryptedEmail = this.encryption.encrypt(userData.email);

    // Create user record
    const userResult = await client.query(
      `INSERT INTO users (
        first_name, last_name, phone_encrypted, phone_hash, 
        email_encrypted, email_hash, password_hash, kyc_status, 
        is_active, preferred_language, created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW()) 
      RETURNING id, first_name, last_name, kyc_status, preferred_language, created_at`,
      [
        userData.firstName,
        userData.lastName,
        JSON.stringify(encryptedPhone),
        this.encryption.hash(userData.phone).hash,
        JSON.stringify(encryptedEmail),
        this.encryption.hash(userData.email).hash,
        hashedPassword,
        'pending',
        true,
        userData.preferredLanguage
      ]
    );

    const user = userResult.rows[0];

    // Create wallet
    const walletResult = await client.query(
      `INSERT INTO wallets (user_id, balance, currency, kyc_level, is_active, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, NOW(), NOW()) RETURNING *`,
      [user.id, this.config.defaultWalletBalance, 'RWF', 1, true]
    );

    // Audit log
    await this.audit.log(auditActions.USER_CREATED, user.id, {
      phone: userData.phone,
      email: userData.email,
      clientInfo,
      correlationId
    }, client);

    return {
      user: {
        id: user.id,
        firstName: user.first_name,
        lastName: user.last_name,
        phone: userData.phone,
        email: userData.email,
        kycStatus: user.kyc_status,
        preferredLanguage: user.preferred_language,
        createdAt: user.created_at
      },
      wallet: walletResult.rows[0]
    };
  }

  async _verifyPassword(password, hash) {
    return bcrypt.compare(password, hash);
  }

  async _checkRateLimit(action, identifier) {
    const isAllowed = await this.rateLimiter.check(action, identifier);
    if (!isAllowed) {
      throw new AppError(ErrorCodes.RATE_LIMIT_EXCEEDED, 'Too many requests');
    }
  }

  async _checkAccountLockout(phone) {
    const lockoutInfo = await this.storage.getAccountLockout(phone);
    if (lockoutInfo && lockoutInfo.locked_until > new Date()) {
      throw new AppError(ErrorCodes.ACCOUNT_LOCKED, 'Account temporarily locked due to failed login attempts');
    }
  }

  async _handleFailedLogin(userId, reason, phone, clientInfo, correlationId) {
    await Promise.all([
      this.storage.recordFailedLogin(phone),
      this.audit.log(auditActions.SECURITY_VIOLATION, userId, {
        action: `login_attempt_${reason}`,
        phone,
        clientInfo,
        correlationId
      })
    ]);
  }

  async _handleSuccessfulLogin(user, clientInfo, correlationId) {
    await Promise.all([
      this.storage.clearFailedLogins(user.phone_hash),
      this.audit.log(auditActions.USER_LOGIN, user.id, {
        clientInfo,
        correlationId
      })
    ]);
  }

  async _changePasswordTransaction(userId, currentPassword, newPassword, clientInfo, client, correlationId) {
    // Get user
    const userResult = await client.query('SELECT * FROM users WHERE id = $1', [userId]);
    const user = userResult.rows[0];

    if (!user) {
      throw new AppError(ErrorCodes.USER_NOT_FOUND, 'User not found');
    }

    // Verify current password
    const isValidPassword = await this._verifyPassword(currentPassword, user.password_hash);
    if (!isValidPassword) {
      await this.audit.log(auditActions.SECURITY_VIOLATION, userId, {
        action: 'password_change_invalid_current',
        clientInfo,
        correlationId
      }, client);
      throw new AppError(ErrorCodes.INVALID_CREDENTIALS, 'Current password is incorrect');
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, this.config.saltRounds);

    // Update password
    await client.query(
      'UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2',
      [hashedPassword, userId]
    );

    // Audit log
    await this.audit.log(auditActions.PASSWORD_CHANGED, userId, {
      clientInfo,
      correlationId
    }, client);

    return { success: true };
  }

  _formatUserResponse(user) {
    return {
      id: user.id,
      firstName: user.first_name,
      lastName: user.last_name,
      phone: user.phone, // Will be decrypted by storage layer
      email: user.email, // Will be decrypted by storage layer
      kycStatus: user.kyc_status,
      preferredLanguage: user.preferred_language
    };
  }

  _generateCorrelationId() {
    return require('crypto').randomUUID();
  }

  _sanitizeUserDataForLog(userData) {
    const { password, ...sanitized } = userData;
    return sanitized;
  }
}

module.exports = { UserService };