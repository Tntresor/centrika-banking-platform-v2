// server.js - Application entry point
require('dotenv').config();

const { AppFactory } = require('./services/service-factory');
const { Logger } = require('./utils/logger');
const { CONFIG } = require('./config');

const logger = new Logger('Server');

class Server {
  constructor() {
    this.appFactory = new AppFactory();
    this.server = null;
    this.isShuttingDown = false;
  }

  async start() {
    try {
      logger.info('Starting Centrika API server...');

      // Create Express app with all services
      const app = await this.appFactory.createApp();

      // Start HTTP server
      this.server = app.listen(CONFIG.app.port, () => {
        logger.info(`Server running on port ${CONFIG.app.port}`, {
          environment: CONFIG.app.env,
          port: CONFIG.app.port
        });
      });

      // Setup graceful shutdown
      this._setupGracefulShutdown();

      // Setup health monitoring
      this._setupHealthMonitoring();

    } catch (error) {
      logger.error('Failed to start server', { error: error.message });
      process.exit(1);
    }
  }

  async stop() {
    if (this.isShuttingDown) {
      return;
    }

    this.isShuttingDown = true;
    logger.info('Shutting down server...');

    try {
      // Stop accepting new connections
      if (this.server) {
        await new Promise((resolve) => {
          this.server.close(resolve);
        });
        logger.info('HTTP server closed');
      }

      // Shutdown services
      await this.appFactory.shutdown();
      logger.info('Services shutdown complete');

    } catch (error) {
      logger.error('Error during shutdown', { error: error.message });
    }
  }

  _setupGracefulShutdown() {
    // Handle process termination signals
    process.on('SIGTERM', async () => {
      logger.info('Received SIGTERM signal');
      await this.stop();
      process.exit(0);
    });

    process.on('SIGINT', async () => {
      logger.info('Received SIGINT signal');
      await this.stop();
      process.exit(0);
    });

    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      logger.error('Uncaught Exception', { error: error.message, stack: error.stack });
      process.exit(1);
    });

    process.on('unhandledRejection', (reason, promise) => {
      logger.error('Unhandled Rejection', { 
        reason: reason?.message || reason,
        promise: promise.toString()
      });
      process.exit(1);
    });
  }

  _setupHealthMonitoring() {
    // Basic health check every 30 seconds
    setInterval(async () => {
      try {
        const health = await this.appFactory.serviceFactory.healthCheck();
        if (health.status !== 'healthy') {
          logger.warn('Health check failed', { health });
        }
      } catch (error) {
        logger.error('Health check error', { error: error.message });
      }
    }, 30000);
  }
}

// Start server if this file is run directly
if (require.main === module) {
  const server = new Server();
  server.start().catch((error) => {
    logger.error('Failed to start application', { error: error.message });
    process.exit(1);
  });
}

module.exports = { Server };

// package.json
{
  "name": "centrika-api",
  "version": "1.0.0",
  "description": "Secure fintech API for Centrika mobile money platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint . --ext .js",
    "lint:fix": "eslint . --ext .js --fix",
    "migrate": "node scripts/migrate.js",
    "seed": "node scripts/seed.js",
    "build": "echo 'No build step required'",
    "docker:build": "docker build -t centrika-api .",
    "docker:run": "docker run -p 3000:3000 centrika-api"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.0",
    "bcryptjs": "^2.4.3",
    "joi": "^17.9.2",
    "winston": "^3.9.0",
    "helmet": "^7.0.0",
    "cors": "^2.8.5",
    "compression": "^1.7.4",
    "dotenv": "^16.1.4",
    "ioredis": "^5.3.2",
    "validator": "^13.9.0",
    "jsonwebtoken": "^9.0.0",
    "cookie-parser": "^1.4.6"
  },
  "devDependencies": {
    "nodemon": "^2.0.22",
    "jest": "^29.5.0",
    "supertest": "^6.3.3",
    "eslint": "^8.42.0",
    "eslint-config-standard": "^17.1.0",
    "@types/jest": "^29.5.2"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=8.0.0"
  },
  "keywords": [
    "fintech",
    "mobile-money",
    "api",
    "rwanda",
    "nodejs",
    "security"
  ],
  "author": "Centrika Team",
  "license": "MIT"
}

// .env.example
# Database Configuration
DATABASE_URL=postgresql://username:password@localhost:5432/centrika_db
DB_POOL_MIN=2
DB_POOL_MAX=10

# Redis Configuration
REDIS_URL=redis://localhost:6379

# Security Configuration
ENCRYPTION_KEY=your-256-bit-hex-encryption-key-here
SESSION_SECRET=your-session-secret-here
SESSION_MAX_AGE=3600000

# Password Security
PBKDF2_ITERATIONS=100000
MAX_LOGIN_ATTEMPTS=5
LOCKOUT_DURATION=900000

# Server Configuration
PORT=3000
NODE_ENV=development
LOG_LEVEL=info

# CORS Configuration
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001

# Wallet Configuration
DEFAULT_WALLET_BALANCE=1000.00
DEFAULT_CURRENCY=RWF

# External Services (if needed)
SMS_API_KEY=your-sms-api-key
SMS_API_URL=https://api.sms-provider.com

# Monitoring (optional)
SENTRY_DSN=your-sentry-dsn-here

// Dockerfile
FROM node:18-alpine

# Create app directory
WORKDIR /usr/src/app

# Install app dependencies
COPY package*.json ./
RUN npm ci --only=production

# Bundle app source
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S centrika -u 1001

# Create logs directory
RUN mkdir -p logs && chown -R centrika:nodejs logs

USER centrika

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node scripts/health-check.js

CMD [ "node", "server.js" ]

// docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://centrika:password@db:5432/centrika_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/usr/src/app/logs
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=centrika_db
      - POSTGRES_USER=centrika
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./migrations:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

// scripts/health-check.js
const http = require('http');

const options = {
  hostname: 'localhost',
  port: process.env.PORT || 3000,
  path: '/health',
  method: 'GET',
  timeout: 2000
};

const request = http.request(options, (res) => {
  if (res.statusCode === 200) {
    process.exit(0);
  } else {
    process.exit(1);
  }
});

request.on('error', () => {
  process.exit(1);
});

request.on('timeout', () => {
  request.destroy();
  process.exit(1);
});

request.end();

// scripts/migrate.js
const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');

async function runMigrations() {
  const pool = new Pool({
    connectionString: process.env.DATABASE_URL
  });

  try {
    console.log('Running database migrations...');
    
    const migrationsDir = path.join(__dirname, '../migrations');
    const files = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort();

    for (const file of files) {
      console.log(`Running migration: ${file}`);
      const sql = fs.readFileSync(path.join(migrationsDir, file), 'utf8');
      await pool.query(sql);
    }

    console.log('Migrations completed successfully');
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

if (require.main === module) {
  runMigrations();
}

module.exports = { runMigrations };